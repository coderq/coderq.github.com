<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人博客"><title>HTTP状态码 | CoderQ·博客</title><link rel="stylesheet" type="text/css" href="/css/normalize.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/pure-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">HTTP状态码</h1><a id="logo" href="/.">CoderQ·博客</a><p class="description">不积硅步无以至千里</p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">HTTP状态码</h1><div class="post-meta">2016-02-01<span class="categories"> | 分类于<a href="/categories/HTTP-TCP-IP/"> HTTP/TCP/IP</a></span></div><div class="post-content"><h2 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h2><ul>
<li>100 (请继续发送) 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</li>
<li>101 (转换协议) 服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本（如HTTP/2）比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。出现场景：使用socket.io时，服务端响应客户端请求后，返回了101状态码。</li>
</ul>
<h2 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h2><ul>
<li>200 (请求成功) 请求已成功，请求所希望的响应头或数据体将随此响应返回。</li>
<li>201 (已创建) 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。restful中，任何创建成功都应该返回该代码。出现场景：使用orientdb的api创建类的时候，http返回201状态码。</li>
<li>202 (已接受，但尚未处理)服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。<br>返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。出现场景：客户端发起了一个请求，该请求需要处理的业务量较大，并且服务端可以直接返回，不需要等待业务执行完之后再返回，则服务端应返回202状态码。</li>
<li>203 (非权威的信息) 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</li>
<li>204 (没有内容) 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</li>
<li>205 (重置内容) 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</li>
</ul>
<h2 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h2><ul>
<li>300 （多种选择） 服务器根据请求可执行多种操作。服务器可根据请求者来选择一项操作，或提供操作列表供其选择。</li>
<li>301 （永久转移） 请求的页面已被永久转移到新的位置。服务器返回此相应时，会自动讲请求者转到新位置。您应使用此代码通知搜索引擎蜘蛛网页或网站已被永久移动到新位置。</li>
<li>302 （临时移动） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。会自动将请求者转到不同的位置。但由于搜索引擎会继续抓取原有位置并将其编入索引，因此您不应该使用此代码来告诉搜索引擎页面或网站已被移动。</li>
<li>303 （查看其他位置） 当请求者应对不同的位置进行单独的GET请求以检索响应时，服务器会返回此代码。对于除head请求之外的所有请求服务器会自动转到其他位置。</li>
<li>304 （未修改） 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应。由于服务器可以告诉搜索引擎自上次抓取后网页没有更改过，因此可以节省带宽和开销。</li>
<li>305 （使用代理） 请求者只能使用代理访问请求的页面。如果服务器返回此响应，那么服务器还会指明应当使用的代理。</li>
<li>307 （临时重定向） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置进行以后的请求。会自动将请求者转移到不同的位置。但由于搜索引擎会继续抓取原有位置并将其编入索引，因此您不应使用此代码来告诉搜索引擎某个页面或网站已被移动。</li>
</ul>
<h2 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h2><ul>
<li>400 (请求错误) 由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。出现场景：使用socket.io时，前后端版本不一致偶尔会导致这样的问题。一般是请求的格式无法被服务端理解所致。</li>
<li>401 (需要认证) 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</li>
<li>402 (需要付款) 该状态码是为了将来可能的需求而预留的。</li>
<li>403 (已被禁止) 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。出现场景：做爬虫经常遇到，解决方法是用代理访问或着修改user-agent为正常浏览器的user-agent。</li>
<li>404 (未找到) 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</li>
<li>405 (方式不被允许) 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。<br>鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</li>
</ul>
<h2 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h2><ul>
<li>500 (服务出错) 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。出现场景：代码执行异常时返回该响应码。</li>
<li>501 (未执行) 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</li>
<li>502 (网关错误) 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。出现场景：使用nginx等服务器作为代理时，如果后端服务器无法被访问，则nginx返回该代码。</li>
<li>503 (服务不可用) 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。</li>
<li>504 (网关超时) 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。<br>注意：某些代理服务器在DNS查询超时时会返回400或者500错误。出现场景：上游服务器已启动，但未及时地对该请求作出响应。</li>
<li>505 (HTTP版本不支持) 服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</li>
</ul>
</div><div class="tags"><a href="/tags/http/">http</a><a href="/tags/状态码/">状态码</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://coderq.github.io"/></form></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP-TCP-IP/">HTTP/TCP/IP</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/状态码/" style="font-size: 15px;">状态码</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/02/01/HTTP状态码/">HTTP状态码</a></li></ul></div><div class="widget"><div class="widget-title">友情链接</div></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">CoderQ·博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/jquery.min.js?v=0.0.0"></script><script type="text/javascript" src="/js/totop.js?v=0.0.0"></script><script type="text/javascript" src="/js/fancybox.pack.js?v=0.0.0"></script><script type="text/javascript" src="/js/jquery.fancybox.js?v=0.0.0"></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>