<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="个人博客"><title>HTTP状态码 | CoderQ·博客</title><link rel="stylesheet" type="text/css" href="/css/normalize.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/pure-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">HTTP状态码</h1><a id="logo" href="/.">CoderQ·博客</a><p class="description">不积硅步无以至千里</p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">HTTP状态码</h1><div class="post-meta">2016-02-01<span class="categories"> | 分类于<a href="/categories/HTTP-TCP-IP/"> HTTP/TCP/IP</a></span></div><span data-thread-key="2016/02/01/http-status-code/" class="ds-thread-count"></span><div class="post-content"><h2 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h2><h3 id="100__28_u8BF7_u7EE7_u7EED_u53D1_u9001_29"><a href="#100__28_u8BF7_u7EE7_u7EED_u53D1_u9001_29" class="headerlink" title="100 (请继续发送)"></a>100 (请继续发送)</h3><p>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</p>
<h3 id="101__28_u8F6C_u6362_u534F_u8BAE_29"><a href="#101__28_u8F6C_u6362_u534F_u8BAE_29" class="headerlink" title="101 (转换协议)"></a>101 (转换协议)</h3><p>服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本（如HTTP/2）比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。出现场景：使用socket.io时，服务端响应客户端请求后，返回了101状态码。</p>
<h2 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h2><h3 id="200__28_u8BF7_u6C42_u6210_u529F_29"><a href="#200__28_u8BF7_u6C42_u6210_u529F_29" class="headerlink" title="200 (请求成功)"></a>200 (请求成功)</h3><p>请求已成功，请求所希望的响应头或数据体将随此响应返回。</p>
<h3 id="201__28_u5DF2_u521B_u5EFA_29"><a href="#201__28_u5DF2_u521B_u5EFA_29" class="headerlink" title="201 (已创建)"></a>201 (已创建)</h3><p>请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。restful中，任何创建成功都应该返回该代码。出现场景：使用orientdb的api创建类的时候，http返回201状态码。</p>
<h3 id="202__28_u5DF2_u63A5_u53D7_uFF0C_u4F46_u5C1A_u672A_u5904_u7406_29"><a href="#202__28_u5DF2_u63A5_u53D7_uFF0C_u4F46_u5C1A_u672A_u5904_u7406_29" class="headerlink" title="202 (已接受，但尚未处理)"></a>202 (已接受，但尚未处理)</h3><p>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。<br>返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。出现场景：客户端发起了一个请求，该请求需要处理的业务量较大，并且服务端可以直接返回，不需要等待业务执行完之后再返回，则服务端应返回202状态码。</p>
<h3 id="203__28_u975E_u6743_u5A01_u7684_u4FE1_u606F_29"><a href="#203__28_u975E_u6743_u5A01_u7684_u4FE1_u606F_29" class="headerlink" title="203 (非权威的信息)"></a>203 (非权威的信息)</h3><p>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</p>
<h3 id="204__28_u6CA1_u6709_u5185_u5BB9_29"><a href="#204__28_u6CA1_u6709_u5185_u5BB9_29" class="headerlink" title="204 (没有内容)"></a>204 (没有内容)</h3><p>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</p>
<ol>
<li>公司需要一个实时查看用户行为的功能，用户行为记录在远程的某台服务器，服务器可以通过一个http地址将用户信息以post的方式推送回来。于是，使用node.js搭建了一个服务，服务提供一个API接口用于接收此信息；另开启一个html实时展示页面，该html页面与服务器以长链接的方式进行通信，当接收信息的API收到具体信息时，将消息通过长链接实时推送给html页面。接收远程服务器抛送过来的信息的API接口，每当收到消息时，返回204代码。</li>
</ol>
<h3 id="205__28_u91CD_u7F6E_u5185_u5BB9_29"><a href="#205__28_u91CD_u7F6E_u5185_u5BB9_29" class="headerlink" title="205 (重置内容)"></a>205 (重置内容)</h3><p>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</p>
<h2 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h2><h3 id="300__28_u591A_u79CD_u9009_u62E9_29"><a href="#300__28_u591A_u79CD_u9009_u62E9_29" class="headerlink" title="300 (多种选择)"></a>300 (多种选择)</h3><p>服务器根据请求可执行多种操作。服务器可根据请求者来选择一项操作，或提供操作列表供其选择。</p>
<h3 id="301__28_u6C38_u4E45_u8F6C_u79FB_29"><a href="#301__28_u6C38_u4E45_u8F6C_u79FB_29" class="headerlink" title="301 (永久转移)"></a>301 (永久转移)</h3><p>请求的页面已被永久转移到新的位置。服务器返回此相应时，会自动讲请求者转到新位置。您应使用此代码通知搜索引擎蜘蛛网页或网站已被永久移动到新位置。</p>
<h3 id="302__28_u4E34_u65F6_u79FB_u52A8_29"><a href="#302__28_u4E34_u65F6_u79FB_u52A8_29" class="headerlink" title="302 (临时移动)"></a>302 (临时移动)</h3><p>服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。会自动将请求者转到不同的位置。但由于搜索引擎会继续抓取原有位置并将其编入索引，因此您不应该使用此代码来告诉搜索引擎页面或网站已被移动。</p>
<h3 id="303__28_u67E5_u770B_u5176_u4ED6_u4F4D_u7F6E_29"><a href="#303__28_u67E5_u770B_u5176_u4ED6_u4F4D_u7F6E_29" class="headerlink" title="303 (查看其他位置)"></a>303 (查看其他位置)</h3><p>当请求者应对不同的位置进行单独的GET请求以检索响应时，服务器会返回此代码。对于除head请求之外的所有请求服务器会自动转到其他位置。</p>
<h3 id="304__28_u672A_u4FEE_u6539_29"><a href="#304__28_u672A_u4FEE_u6539_29" class="headerlink" title="304 (未修改)"></a>304 (未修改)</h3><p>自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应。由于服务器可以告诉搜索引擎自上次抓取后网页没有更改过，因此可以节省带宽和开销。</p>
<h3 id="305__28_u4F7F_u7528_u4EE3_u7406_29"><a href="#305__28_u4F7F_u7528_u4EE3_u7406_29" class="headerlink" title="305 (使用代理)"></a>305 (使用代理)</h3><p>请求者只能使用代理访问请求的页面。如果服务器返回此响应，那么服务器还会指明应当使用的代理。</p>
<h3 id="307__28_u4E34_u65F6_u91CD_u5B9A_u5411_29"><a href="#307__28_u4E34_u65F6_u91CD_u5B9A_u5411_29" class="headerlink" title="307 (临时重定向)"></a>307 (临时重定向)</h3><p>服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置进行以后的请求。会自动将请求者转移到不同的位置。但由于搜索引擎会继续抓取原有位置并将其编入索引，因此您不应使用此代码来告诉搜索引擎某个页面或网站已被移动。</p>
<h2 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h2><h3 id="400__28_u8BF7_u6C42_u9519_u8BEF_29"><a href="#400__28_u8BF7_u6C42_u9519_u8BEF_29" class="headerlink" title="400 (请求错误)"></a>400 (请求错误)</h3><p>由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。出现场景：使用socket.io时，前后端版本不一致偶尔会导致这样的问题。一般是请求的格式无法被服务端理解所致。</p>
<h3 id="401__28_u9700_u8981_u8BA4_u8BC1_29"><a href="#401__28_u9700_u8981_u8BA4_u8BC1_29" class="headerlink" title="401 (需要认证)"></a>401 (需要认证)</h3><p>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</p>
<h3 id="402__28_u9700_u8981_u4ED8_u6B3E_29"><a href="#402__28_u9700_u8981_u4ED8_u6B3E_29" class="headerlink" title="402 (需要付款)"></a>402 (需要付款)</h3><p>该状态码是为了将来可能的需求而预留的。</p>
<h3 id="403__28_u5DF2_u88AB_u7981_u6B62_29"><a href="#403__28_u5DF2_u88AB_u7981_u6B62_29" class="headerlink" title="403 (已被禁止)"></a>403 (已被禁止)</h3><p>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。出现场景：做爬虫经常遇到，解决方法是用代理访问或着修改user-agent为正常浏览器的user-agent。</p>
<h3 id="404__28_u672A_u627E_u5230_29"><a href="#404__28_u672A_u627E_u5230_29" class="headerlink" title="404 (未找到)"></a>404 (未找到)</h3><p>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</p>
<h3 id="405__28_u65B9_u5F0F_u4E0D_u88AB_u5141_u8BB8_29"><a href="#405__28_u65B9_u5F0F_u4E0D_u88AB_u5141_u8BB8_29" class="headerlink" title="405 (方式不被允许)"></a>405 (方式不被允许)</h3><p>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。<br>鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p>
<h3 id="406__28_u65E0_u6CD5_u63A5_u53D7_u7684_u8BF7_u6C42_29"><a href="#406__28_u65E0_u6CD5_u63A5_u53D7_u7684_u8BF7_u6C42_29" class="headerlink" title="406 (无法接受的请求)"></a>406 (无法接受的请求)</h3><p>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。<br>除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</p>
<ol>
<li>假如客户端要求服务端以某种压缩格式返回内容，例如gzip，但服务端并不支持该功能，则服务端返回406状态码。<h3 id="407__28_u4EE3_u7406_u9700_u8981_u8BA4_u8BC1_29"><a href="#407__28_u4EE3_u7406_u9700_u8981_u8BA4_u8BC1_29" class="headerlink" title="407 (代理需要认证)"></a>407 (代理需要认证)</h3>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。参见RFC 2617。<h3 id="409__28_u51B2_u7A81_29"><a href="#409__28_u51B2_u7A81_29" class="headerlink" title="409 (冲突)"></a>409 (冲突)</h3>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。<br>冲突通常发生于对PUT请求的处理中。例如，在采用版本检查的环境下，某次PUT提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。使用post创建资源时发生冲突。。。</li>
</ol>
<h2 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h2><h3 id="500__28_u670D_u52A1_u51FA_u9519_29"><a href="#500__28_u670D_u52A1_u51FA_u9519_29" class="headerlink" title="500 (服务出错)"></a>500 (服务出错)</h3><p>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。出现场景：代码执行异常时返回该响应码。</p>
<h3 id="501__28_u672A_u6267_u884C_29"><a href="#501__28_u672A_u6267_u884C_29" class="headerlink" title="501 (未执行)"></a>501 (未执行)</h3><p>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</p>
<h3 id="502__28_u7F51_u5173_u9519_u8BEF_29"><a href="#502__28_u7F51_u5173_u9519_u8BEF_29" class="headerlink" title="502 (网关错误)"></a>502 (网关错误)</h3><p>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。出现场景：使用nginx等服务器作为代理时，如果后端服务器无法被访问，则nginx返回该代码。</p>
<h3 id="503__28_u670D_u52A1_u4E0D_u53EF_u7528_29"><a href="#503__28_u670D_u52A1_u4E0D_u53EF_u7528_29" class="headerlink" title="503 (服务不可用)"></a>503 (服务不可用)</h3><p>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。</p>
<h3 id="504__28_u7F51_u5173_u8D85_u65F6_29"><a href="#504__28_u7F51_u5173_u8D85_u65F6_29" class="headerlink" title="504 (网关超时)"></a>504 (网关超时)</h3><p>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。注意：某些代理服务器在DNS查询超时时会返回400或者500错误。出现场景：上游服务器已启动，但未及时地对该请求作出响应。</p>
<h3 id="505__28HTTP_u7248_u672C_u4E0D_u652F_u6301_29__u670D_u52A1_u5668_u4E0D_u652F_u6301_uFF0C_u6216_u8005_u62D2_u7EDD_u652F_u6301_u5728_u8BF7_u6C42_u4E2D_u4F7F_u7528_u7684HTTP_u7248_u672C_u3002_u8FD9_u6697_u793A_u7740_u670D_u52A1_u5668_u4E0D_u80FD_u6216_u4E0D_u613F_u4F7F_u7528_u4E0E_u5BA2_u6237_u7AEF_u76F8_u540C_u7684_u7248_u672C_u3002_u54CD_u5E94_u4E2D_u5E94_u5F53_u5305_u542B_u4E00_u4E2A_u63CF_u8FF0_u4E86_u4E3A_u4F55_u7248_u672C_u4E0D_u88AB_u652F_u6301_u4EE5_u53CA_u670D_u52A1_u5668_u652F_u6301_u54EA_u4E9B_u534F_u8BAE_u7684_u5B9E_u4F53_u3002"><a href="#505__28HTTP_u7248_u672C_u4E0D_u652F_u6301_29__u670D_u52A1_u5668_u4E0D_u652F_u6301_uFF0C_u6216_u8005_u62D2_u7EDD_u652F_u6301_u5728_u8BF7_u6C42_u4E2D_u4F7F_u7528_u7684HTTP_u7248_u672C_u3002_u8FD9_u6697_u793A_u7740_u670D_u52A1_u5668_u4E0D_u80FD_u6216_u4E0D_u613F_u4F7F_u7528_u4E0E_u5BA2_u6237_u7AEF_u76F8_u540C_u7684_u7248_u672C_u3002_u54CD_u5E94_u4E2D_u5E94_u5F53_u5305_u542B_u4E00_u4E2A_u63CF_u8FF0_u4E86_u4E3A_u4F55_u7248_u672C_u4E0D_u88AB_u652F_u6301_u4EE5_u53CA_u670D_u52A1_u5668_u652F_u6301_u54EA_u4E9B_u534F_u8BAE_u7684_u5B9E_u4F53_u3002" class="headerlink" title="505 (HTTP版本不支持) 服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。"></a>505 (HTTP版本不支持) 服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</h3></div><div class="tags"><a href="/tags/http/">http</a><a href="/tags/状态码/">状态码</a></div><div class="post-nav"><a href="/2016/02/02/mac-commands/" class="pre"><i class="icon-previous">MAC常用命令（一）</i></a></div><div data-thread-key="2016/02/01/http-status-code/" data-title="HTTP状态码" data-url="http://coderq.github.io/2016/02/01/http-status-code/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/02/01/http-status-code/" data-title="HTTP状态码" data-url="http://coderq.github.io/2016/02/01/http-status-code/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://coderq.github.io"/></form></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP-TCP-IP/">HTTP/TCP/IP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis学习笔记/">Redis学习笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/html-css/">html+css</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-js/">node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/opencv/">opencv</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/unix-linux-mac/">unix/linux/mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/进程-线程/">进程/线程</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/node-js/" style="font-size: 15px;">node.js</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/stream-node-js/" style="font-size: 15px;">stream node.js</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/bash/" style="font-size: 15px;">bash</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/状态码/" style="font-size: 15px;">状态码</a> <a href="/tags/css-fex/" style="font-size: 15px;">css, fex</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/03/17/flex-stylesheet-study/">flex布局学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/09/nodejs-stream/">node.js使用stream处理大文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/08/javascript-proto-prototype-constructor/">Javascript继承之理解__proto__、prototype、constructor三者的含义与用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/08/javascript-es5-useless-tech/">Javascript中一些可能是用较少的语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/08/npm-useful-logs/">npm命令使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/03/nginx-config/">nginx配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/02/create-openssl-certificate-for-https/">通过OpenSSL创建证书文件构建https服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/29/decode-utf8/">html中UTF8编码的解码</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/27/mongodb-update-by-self-field/">mongodb的文档如何通过自己的某些字段更新文档的方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/22/javascript-merge-sort/">javascript实现合并排序</a></li></ul></div><div class="widget"><div class="comments-title">最近评论</div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title">友情链接</div></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">CoderQ·博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/jquery.min.js?v=0.0.0"></script><script type="text/javascript" src="/js/totop.js?v=0.0.0"></script><script type="text/javascript" src="/js/fancybox.pack.js?v=0.0.0"></script><script type="text/javascript" src="/js/jquery.fancybox.js?v=0.0.0"></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'coderq'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>